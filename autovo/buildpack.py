#!/usr/bin/env python3
import json
import re
import shutil
from pathlib import Path


def find_source_mods(root: Path, pack_mod_dir_name: str):
    """
    Find Auto-VO source mods under `root` that we should merge.

    Criteria:
      - Directory under `root`
      - Contains vo_lines.json
      - Contains sounds/ with .wav files

    We also skip the combined pack dir itself (pack_mod_dir_name), so you can
    re-run the builder without it re-ingesting its own output.
    """
    mods = []
    for child in root.iterdir():
        if not child.is_dir():
            continue

        # Skip the combined pack directory if it already exists
        if child.name.lower() == pack_mod_dir_name.lower():
            continue

        vo_meta = child / "vo_lines.json"
        sounds_dir = child / "sounds"

        if vo_meta.is_file() and sounds_dir.is_dir():
            # Only consider it a real source mod if it has at least one wav
            if any(sounds_dir.glob("*.wav")):
                mods.append((child, vo_meta, sounds_dir))

    return mods


def sanitize_pack_id(name: str) -> str:
    """
    Turn a user-entered name into a safe WeiDU mod ID / folder suffix.
    Keep alnum + underscore, lowercased. Fallback to 'smoulderingcorpsevo'
    if we end up with an empty string.
    """
    s = re.sub(r"[^A-Za-z0-9_]", "", name)
    s = s.strip("_").lower()
    if not s:
        s = "smoulderingcorpsevo"
    return s


def load_vo_lines(vo_meta_path: Path):
    """
    Load vo_lines.json and return the entries array.
    Expect schema:
      {
        "dlg_basename": "...",
        "mod_id": "autovo/...",
        "entries": [
           { "strref": ..., "resref": "...", "text": "...", "wav": "sounds/XXX.wav" },
           ...
        ]
      }
    """
    with vo_meta_path.open("r", encoding="utf-8") as f:
        data = json.load(f)

    entries = data.get("entries", [])
    if not isinstance(entries, list):
        raise SystemExit(f"{vo_meta_path} has unexpected format (entries not list).")

    return entries


def copy_wavs_to_pack(source_sounds: Path, dest_sounds: Path):
    """
    Copy all wavs from `source_sounds` into `dest_sounds`, skipping exact
    duplicates (same name and size). Warn on conflicting sizes.
    """
    count_copied = 0
    count_skipped = 0

    for wav in source_sounds.glob("*.wav"):
        dest = dest_sounds / wav.name
        if dest.exists():
            if dest.stat().st_size != wav.stat().st_size:
                print(
                    f"[WARN] WAV name conflict: {dest.name} already exists with "
                    f"different size; keeping existing."
                )
            count_skipped += 1
            continue
        shutil.copy2(wav, dest)
        count_copied += 1

    print(
        f"[DEBUG] Copied {count_copied} wav(s) from {source_sounds.parent.name}, "
        f"skipped {count_skipped} existing."
    )
    return count_copied, count_skipped


def safe_tp2_text(text: str) -> str:
    """
    Make TLK text safe for embedding between ~ ~ in STRING_SET lines.
    Mirror the main Auto-VO pipeline behavior: replace '~' with '`'.
    """
    if text is None:
        return ""
    t = str(text).replace("\r\n", "\n")
    t = t.replace("~", "`")
    return t


def build_combined_tp2(
    setup_tp2_path: Path,
    mod_id: str,
    pack_title: str,
    combined_entries: dict[int, dict],
):
    """
    Write a single TP2 that looks like the ones generated by build_autovo.py.

    combined_entries: dict[strref] -> {
        "strref": int,
        "resref": str,
        "text": str
    }
    """
    with setup_tp2_path.open("w", encoding="utf-8") as f:
        f.write(f'BACKUP ~{mod_id}/backup~\n')
        f.write('AUTHOR ~Auto-VO pipeline (combined VO pack)~\n\n')
        f.write(f'BEGIN ~Auto-VO for {pack_title} (VoxCPM)~\n\n')

        # COPY blocks
        seen_resrefs = set()
        for sr in sorted(combined_entries.keys()):
            entry = combined_entries[sr]
            resref = entry["resref"]
            if resref in seen_resrefs:
                continue
            seen_resrefs.add(resref)
            fname = f"{resref}.wav"
            f.write(f'COPY ~{mod_id}/sounds/{fname}~ ~override/{fname}~\n')
        f.write("\n")

        # STRING_SET blocks
        seen_pairs = set()
        for sr in sorted(combined_entries.keys()):
            entry = combined_entries[sr]
            strref = entry["strref"]
            resref = entry["resref"]
            pair = (strref, resref)
            if pair in seen_pairs:
                continue
            seen_pairs.add(pair)

            text = entry.get("text", "")
            safe = safe_tp2_text(text)
            f.write(f'STRING_SET {strref} ~{safe}~ [{resref}]\n')

    print(f"[INFO] Wrote combined TP2: {setup_tp2_path}")


def main():
    # Typically you run this from D:\\00PlaneScapeMod\\autovo
    root = Path.cwd()
    print(f"[INFO] Combining all Auto-VO mods in: {root}")

    default_title = "Smouldering Corpse VO Pack"
    default_id = "SmoulderingCorpseVO"

    pack_title = input(
        f"\nDisplay name for combined pack [{default_title}]: "
    ).strip()
    if not pack_title:
        pack_title = default_title

    pack_id_raw = input(
        f"Internal pack ID (for folder / WeiDU) [{default_id}]: "
    ).strip()
    if not pack_id_raw:
        pack_id_raw = default_id

    pack_id = sanitize_pack_id(pack_id_raw)
    pack_mod_dir_name = f"autovo_{pack_id}"
    mod_id = f"autovo/{pack_mod_dir_name}"

    print(f"[INFO] Using pack ID: {pack_id}")
    print(f"[INFO] Combined mod folder: {pack_mod_dir_name}")
    print(f"[INFO] WeiDU MOD_ID: {mod_id}")

    # Where the combined mod will live:
    pack_mod_dir = root / pack_mod_dir_name
    pack_sounds_dir = pack_mod_dir / "sounds"
    pack_backup_dir = pack_mod_dir / "backup"

    # Discover source mods, excluding the combined folder if it exists
    source_mods = find_source_mods(root, pack_mod_dir_name)
    if not source_mods:
        print(
            "[ERROR] No source mods found.\n"
            "Expected subdirectories with vo_lines.json and sounds/."
        )
        return

    print("\n[INFO] Found the following source mods:")
    for mod_dir, vo_meta, sounds_dir in source_mods:
        print(f"  - {mod_dir.name} (meta: {vo_meta.name}, sounds: {sounds_dir})")

    if pack_mod_dir.exists():
        ans = input(
            f"\n[WARN] Output directory '{pack_mod_dir}' already exists. "
            f"Overwrite? [y/N]: "
        ).strip().lower()
        if ans not in ("y", "yes"):
            print("[INFO] Aborting; not overwriting existing combined pack.")
            return
        shutil.rmtree(pack_mod_dir)

    # Create new pack dirs
    pack_sounds_dir.mkdir(parents=True, exist_ok=True)
    pack_backup_dir.mkdir(parents=True, exist_ok=True)

    # Aggregate entries
    combined_entries: dict[int, dict] = {}
    total_wavs_copied = 0

    for mod_dir, vo_meta, sounds_dir in source_mods:
        print(f"\n[INFO] Processing source mod: {mod_dir.name}")
        entries = load_vo_lines(vo_meta)

        # Copy audio
        copied, skipped = copy_wavs_to_pack(sounds_dir, pack_sounds_dir)
        total_wavs_copied += copied

        for e in entries:
            strref = e.get("strref")
            resref = e.get("resref")
            text = e.get("text", "")
            if strref is None or resref is None:
                print(
                    f"[WARN] Skipping malformed entry in {vo_meta}: "
                    f"{e!r}"
                )
                continue

            if strref in combined_entries:
                existing = combined_entries[strref]
                if existing["resref"] != resref:
                    print(
                        f"[WARN] Conflicting mapping for strref {strref}:\n"
                        f"       Existing: resref={existing['resref']} from earlier mod\n"
                        f"       New     : resref={resref} from {mod_dir.name}\n"
                        f"       Keeping first."
                    )
                continue

            combined_entries[strref] = {
                "strref": strref,
                "resref": resref,
                "text": text,
            }

    if not combined_entries:
        print("[ERROR] No entries collected from source mods; nothing to build.")
        return

    print(
        f"\n[INFO] Aggregated {len(combined_entries)} unique strref(s) "
        f"with VO from {len(source_mods)} source mod(s)."
    )
    print(f"[INFO] Total new wavs copied into pack: {total_wavs_copied}")

    # Build TP2 inside the combined mod dir with the pattern the installer expects:
    #   setup-autovo_<pack_id>.tp2
    setup_tp2_path = pack_mod_dir / f"setup-autovo_{pack_id}.tp2"
    build_combined_tp2(setup_tp2_path, mod_id, pack_title, combined_entries)

    print("\n[INFO] Combined pack ready.")
    print(f"[INFO] Mod directory: {pack_mod_dir}")
    print(f"[INFO] TP2 file    : {setup_tp2_path}")
    print(
        "[INFO] Your existing PowerShell installer should now detect this "
        "as another Auto-VO component (setup-autovo_*.tp2)."
    )


if __name__ == "__main__":
    main()
